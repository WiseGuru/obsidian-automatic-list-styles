/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoListStylesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var AutoListStylesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("AutoListStylesPlugin loaded");
    this.registerMarkdownPostProcessor((el, ctx) => {
      el.querySelectorAll("ol").forEach((list) => {
        console.log("Processing ordered list: ", list);
        const firstText = getFirstTextNode(list.querySelector("li"));
        if (firstText && firstText.textContent) {
          const indentLevel = getIndentLevel(list);
          console.log("Indent level for ordered list: ", indentLevel);
          const listStyleType = getListStyleType(indentLevel);
          list.style.listStyleType = listStyleType;
          firstText.textContent = firstText.textContent.trim();
        }
      });
      const processedLists = /* @__PURE__ */ new Set();
      const ulElements = el.querySelectorAll("ul");
      ulElements.forEach((list, index) => {
        if (processedLists.has(list))
          return;
        processedLists.add(list);
        const indentLevel = getIndentLevel(list);
        const listStyleType = getUnorderedListStyleType(indentLevel);
        if (list.className.includes("has-list-bullet")) {
          list.className = list.className.replace("has-list-bullet", "").trim();
        }
        list.style.listStyleType = listStyleType;
      });
    });
  }
};
function getFirstTextNode(node) {
  console.log("getFirstTextNode called with node: ", node);
  if (node == null)
    return null;
  for (let i = 0; i < node.childNodes.length; i++) {
    if (node.childNodes[i].nodeType === Node.TEXT_NODE) {
      return node.childNodes[i];
    } else if (node.childNodes[i].hasChildNodes()) {
      const childText = getFirstTextNode(node.childNodes[i]);
      if (childText)
        return childText;
    }
  }
  return null;
}
function getIndentLevel(list) {
  let indentLevel = 0;
  let parent = list.parentElement;
  while (parent) {
    if (parent.tagName === "OL" || parent.tagName === "UL") {
      indentLevel++;
    }
    parent = parent.parentElement;
  }
  console.log("Calculated indent level for list: ", indentLevel);
  return indentLevel;
}
function getListStyleType(indentLevel) {
  console.log("getListStyleType called with indentLevel: ", indentLevel);
  const defaultStyles = [
    "decimal",
    "lower-alpha",
    "lower-roman",
    "upper-alpha",
    "upper-roman",
    "decimal-leading-zero"
  ];
  const defaultStyleIndex = indentLevel % defaultStyles.length;
  return defaultStyles[defaultStyleIndex];
}
function getUnorderedListStyleType(indentLevel) {
  const unorderedListStyles = [
    "disc",
    "square",
    "circle"
  ];
  const styleIndex = indentLevel % unorderedListStyles.length;
  return unorderedListStyles[styleIndex];
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luLCBNYXJrZG93blBvc3RQcm9jZXNzb3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9MaXN0U3R5bGVzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuICBhc3luYyBvbmxvYWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcIkF1dG9MaXN0U3R5bGVzUGx1Z2luIGxvYWRlZFwiKTsgLy8gTG9nIHdoZW4gdGhlIHBsdWdpbiBpcyBsb2FkZWRcclxuXHJcbiAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKChlbCwgY3R4KSA9PiB7XHJcbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBvcmRlcmVkIGxpc3QgKDxvbD4pIGluIHRoZSBkb2N1bWVudFxyXG4gICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwib2xcIikuZm9yRWFjaCgobGlzdCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBvcmRlcmVkIGxpc3Q6IFwiLCBsaXN0KTsgLy8gTG9nIHRoZSBjdXJyZW50IG9yZGVyZWQgbGlzdCBiZWluZyBwcm9jZXNzZWRcclxuICAgICAgICBjb25zdCBmaXJzdFRleHQgPSBnZXRGaXJzdFRleHROb2RlKGxpc3QucXVlcnlTZWxlY3RvcihcImxpXCIpKTtcclxuICAgICAgICBpZiAoZmlyc3RUZXh0ICYmIGZpcnN0VGV4dC50ZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgY29uc3QgaW5kZW50TGV2ZWwgPSBnZXRJbmRlbnRMZXZlbChsaXN0KTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5kZW50IGxldmVsIGZvciBvcmRlcmVkIGxpc3Q6IFwiLCBpbmRlbnRMZXZlbCk7IC8vIExvZyB0aGUgaW5kZW50IGxldmVsIGZvciBvcmRlcmVkIGxpc3RcclxuICAgICAgICAgIGNvbnN0IGxpc3RTdHlsZVR5cGUgPSBnZXRMaXN0U3R5bGVUeXBlKGluZGVudExldmVsKTtcclxuICAgICAgICAgIGxpc3Quc3R5bGUubGlzdFN0eWxlVHlwZSA9IGxpc3RTdHlsZVR5cGU7XHJcbiAgICAgICAgICBmaXJzdFRleHQudGV4dENvbnRlbnQgPSBmaXJzdFRleHQudGV4dENvbnRlbnQudHJpbSgpOyAvLyBUcmltIHRoZSBmaXJzdCB0ZXh0IG5vZGUncyBjb250ZW50XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFVzZSBhIFNldCB0byBrZWVwIHRyYWNrIG9mIHByb2Nlc3NlZCB1bm9yZGVyZWQgbGlzdHMgdG8gYXZvaWQgZHVwbGljYXRlc1xyXG4gICAgICBjb25zdCBwcm9jZXNzZWRMaXN0cyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XHJcblxyXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggdW5vcmRlcmVkIGxpc3QgKDx1bD4pIGluIHRoZSBkb2N1bWVudFxyXG4gICAgICBjb25zdCB1bEVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChcInVsXCIpO1xyXG4gICAgICB1bEVsZW1lbnRzLmZvckVhY2goKGxpc3QsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3NlZExpc3RzLmhhcyhsaXN0KSkgcmV0dXJuOyAvLyBTa2lwIGFscmVhZHkgcHJvY2Vzc2VkIGxpc3RzXHJcbiAgICAgICAgcHJvY2Vzc2VkTGlzdHMuYWRkKGxpc3QpOyAvLyBNYXJrIHRoaXMgbGlzdCBhcyBwcm9jZXNzZWRcclxuXHJcbiAgICAgICAgY29uc3QgaW5kZW50TGV2ZWwgPSBnZXRJbmRlbnRMZXZlbChsaXN0KTtcclxuICAgICAgICBjb25zdCBsaXN0U3R5bGVUeXBlID0gZ2V0VW5vcmRlcmVkTGlzdFN0eWxlVHlwZShpbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgaWYgKGxpc3QuY2xhc3NOYW1lLmluY2x1ZGVzKFwiaGFzLWxpc3QtYnVsbGV0XCIpKSB7XHJcbiAgICAgICAgICBsaXN0LmNsYXNzTmFtZSA9IGxpc3QuY2xhc3NOYW1lLnJlcGxhY2UoXCJoYXMtbGlzdC1idWxsZXRcIiwgXCJcIikudHJpbSgpOyAvLyBDbGVhbiB1cCBjbGFzcyBuYW1lIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0LnN0eWxlLmxpc3RTdHlsZVR5cGUgPSBsaXN0U3R5bGVUeXBlOyAvLyBBcHBseSB0aGUgY2FsY3VsYXRlZCBsaXN0IHN0eWxlXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCB0ZXh0IG5vZGUgd2l0aGluIGEgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGlzIGZvdW5kXHJcbmZ1bmN0aW9uIGdldEZpcnN0VGV4dE5vZGUobm9kZTogTm9kZSk6IENoaWxkTm9kZSB8IG51bGwge1xyXG4gIGNvbnNvbGUubG9nKFwiZ2V0Rmlyc3RUZXh0Tm9kZSBjYWxsZWQgd2l0aCBub2RlOiBcIiwgbm9kZSk7IC8vIExvZyBmdW5jdGlvbiBjYWxsXHJcbiAgaWYgKG5vZGUgPT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW2ldO1xyXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkTm9kZXNbaV0uaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkVGV4dCA9IGdldEZpcnN0VGV4dE5vZGUobm9kZS5jaGlsZE5vZGVzW2ldKTtcclxuICAgICAgaWYgKGNoaWxkVGV4dCkgcmV0dXJuIGNoaWxkVGV4dDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZXMgdGhlIGluZGVudCBsZXZlbCBvZiBhIGxpc3QgYnkgY291bnRpbmcgaXRzIHBhcmVudCBPTC9VTCBlbGVtZW50c1xyXG5mdW5jdGlvbiBnZXRJbmRlbnRMZXZlbChsaXN0OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XHJcbiAgbGV0IGluZGVudExldmVsID0gMDtcclxuICBsZXQgcGFyZW50ID0gbGlzdC5wYXJlbnRFbGVtZW50O1xyXG4gIHdoaWxlIChwYXJlbnQpIHtcclxuICAgIGlmIChwYXJlbnQudGFnTmFtZSA9PT0gXCJPTFwiIHx8IHBhcmVudC50YWdOYW1lID09PSBcIlVMXCIpIHtcclxuICAgICAgaW5kZW50TGV2ZWwrKzsgLy8gSW5jcmVtZW50IGluZGVudCBsZXZlbCBmb3IgZWFjaCBPTC9VTCBwYXJlbnRcclxuICAgIH1cclxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xyXG4gIH1cclxuICBjb25zb2xlLmxvZyhcIkNhbGN1bGF0ZWQgaW5kZW50IGxldmVsIGZvciBsaXN0OiBcIiwgaW5kZW50TGV2ZWwpOyAvLyBMb2cgdGhlIGZpbmFsIGNhbGN1bGF0ZWQgaW5kZW50IGxldmVsXHJcbiAgcmV0dXJuIGluZGVudExldmVsO1xyXG59XHJcblxyXG4vLyBEZXRlcm1pbmVzIHRoZSBzdHlsZSBvZiBhbiBvcmRlcmVkIGxpc3QgYmFzZWQgb24gaXRzIGluZGVudCBsZXZlbFxyXG5mdW5jdGlvbiBnZXRMaXN0U3R5bGVUeXBlKGluZGVudExldmVsOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGNvbnNvbGUubG9nKFwiZ2V0TGlzdFN0eWxlVHlwZSBjYWxsZWQgd2l0aCBpbmRlbnRMZXZlbDogXCIsIGluZGVudExldmVsKTsgLy8gTG9nIGZ1bmN0aW9uIGNhbGxcclxuICBjb25zdCBkZWZhdWx0U3R5bGVzID0gW1xyXG4gICAgXCJkZWNpbWFsXCIsXHJcbiAgICBcImxvd2VyLWFscGhhXCIsXHJcbiAgICBcImxvd2VyLXJvbWFuXCIsXHJcbiAgICBcInVwcGVyLWFscGhhXCIsXHJcbiAgICBcInVwcGVyLXJvbWFuXCIsXHJcbiAgICBcImRlY2ltYWwtbGVhZGluZy16ZXJvXCJcclxuICBdO1xyXG4gIGNvbnN0IGRlZmF1bHRTdHlsZUluZGV4ID0gaW5kZW50TGV2ZWwgJSBkZWZhdWx0U3R5bGVzLmxlbmd0aDtcclxuICByZXR1cm4gZGVmYXVsdFN0eWxlc1tkZWZhdWx0U3R5bGVJbmRleF07IC8vIFJldHVybiB0aGUgc3R5bGUgY29ycmVzcG9uZGluZyB0byB0aGUgaW5kZW50IGxldmVsXHJcbn1cclxuXHJcbi8vIERldGVybWluZXMgdGhlIHN0eWxlIG9mIGFuIHVub3JkZXJlZCBsaXN0IGJhc2VkIG9uIGl0cyBpbmRlbnQgbGV2ZWxcclxuZnVuY3Rpb24gZ2V0VW5vcmRlcmVkTGlzdFN0eWxlVHlwZShpbmRlbnRMZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcclxuICBjb25zdCB1bm9yZGVyZWRMaXN0U3R5bGVzID0gW1xyXG4gICAgXCJkaXNjXCIsXHJcbiAgICBcInNxdWFyZVwiLFxyXG4gICAgXCJjaXJjbGVcIlxyXG4gIF07XHJcbiAgY29uc3Qgc3R5bGVJbmRleCA9IGluZGVudExldmVsICUgdW5vcmRlcmVkTGlzdFN0eWxlcy5sZW5ndGg7XHJcbiAgcmV0dXJuIHVub3JkZXJlZExpc3RTdHlsZXNbc3R5bGVJbmRleF07IC8vIFJldHVybiB0aGUgc3R5bGUgY29ycmVzcG9uZGluZyB0byB0aGUgaW5kZW50IGxldmVsXHJcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQThDO0FBRTlDLElBQXFCLHVCQUFyQixjQUFrRCx1QkFBTztBQUFBLEVBQ3ZELE1BQU0sU0FBUztBQUNiLFlBQVEsSUFBSSw2QkFBNkI7QUFFekMsU0FBSyw4QkFBOEIsQ0FBQyxJQUFJLFFBQVE7QUFFOUMsU0FBRyxpQkFBaUIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxTQUFTO0FBQzFDLGdCQUFRLElBQUksNkJBQTZCLElBQUk7QUFDN0MsY0FBTSxZQUFZLGlCQUFpQixLQUFLLGNBQWMsSUFBSSxDQUFDO0FBQzNELFlBQUksYUFBYSxVQUFVLGFBQWE7QUFDdEMsZ0JBQU0sY0FBYyxlQUFlLElBQUk7QUFDdkMsa0JBQVEsSUFBSSxtQ0FBbUMsV0FBVztBQUMxRCxnQkFBTSxnQkFBZ0IsaUJBQWlCLFdBQVc7QUFDbEQsZUFBSyxNQUFNLGdCQUFnQjtBQUMzQixvQkFBVSxjQUFjLFVBQVUsWUFBWSxLQUFLO0FBQUEsUUFDckQ7QUFBQSxNQUNGLENBQUM7QUFHRCxZQUFNLGlCQUFpQixvQkFBSSxJQUFpQjtBQUc1QyxZQUFNLGFBQWEsR0FBRyxpQkFBaUIsSUFBSTtBQUMzQyxpQkFBVyxRQUFRLENBQUMsTUFBTSxVQUFVO0FBQ2xDLFlBQUksZUFBZSxJQUFJLElBQUk7QUFBRztBQUM5Qix1QkFBZSxJQUFJLElBQUk7QUFFdkIsY0FBTSxjQUFjLGVBQWUsSUFBSTtBQUN2QyxjQUFNLGdCQUFnQiwwQkFBMEIsV0FBVztBQUMzRCxZQUFJLEtBQUssVUFBVSxTQUFTLGlCQUFpQixHQUFHO0FBQzlDLGVBQUssWUFBWSxLQUFLLFVBQVUsUUFBUSxtQkFBbUIsRUFBRSxFQUFFLEtBQUs7QUFBQSxRQUN0RTtBQUNBLGFBQUssTUFBTSxnQkFBZ0I7QUFBQSxNQUM3QixDQUFDO0FBQUEsSUFDSCxDQUFDO0FBQUEsRUFDSDtBQUNGO0FBR0EsMEJBQTBCLE1BQThCO0FBQ3RELFVBQVEsSUFBSSx1Q0FBdUMsSUFBSTtBQUN2RCxNQUFJLFFBQVE7QUFBTSxXQUFPO0FBRXpCLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxXQUFXLFFBQVEsS0FBSztBQUMvQyxRQUFJLEtBQUssV0FBVyxHQUFHLGFBQWEsS0FBSyxXQUFXO0FBQ2xELGFBQU8sS0FBSyxXQUFXO0FBQUEsSUFDekIsV0FBVyxLQUFLLFdBQVcsR0FBRyxjQUFjLEdBQUc7QUFDN0MsWUFBTSxZQUFZLGlCQUFpQixLQUFLLFdBQVcsRUFBRTtBQUNyRCxVQUFJO0FBQVcsZUFBTztBQUFBLElBQ3hCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUdBLHdCQUF3QixNQUEyQjtBQUNqRCxNQUFJLGNBQWM7QUFDbEIsTUFBSSxTQUFTLEtBQUs7QUFDbEIsU0FBTyxRQUFRO0FBQ2IsUUFBSSxPQUFPLFlBQVksUUFBUSxPQUFPLFlBQVksTUFBTTtBQUN0RDtBQUFBLElBQ0Y7QUFDQSxhQUFTLE9BQU87QUFBQSxFQUNsQjtBQUNBLFVBQVEsSUFBSSxzQ0FBc0MsV0FBVztBQUM3RCxTQUFPO0FBQ1Q7QUFHQSwwQkFBMEIsYUFBNkI7QUFDckQsVUFBUSxJQUFJLDhDQUE4QyxXQUFXO0FBQ3JFLFFBQU0sZ0JBQWdCO0FBQUEsSUFDcEI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxRQUFNLG9CQUFvQixjQUFjLGNBQWM7QUFDdEQsU0FBTyxjQUFjO0FBQ3ZCO0FBR0EsbUNBQW1DLGFBQTZCO0FBQzlELFFBQU0sc0JBQXNCO0FBQUEsSUFDMUI7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGFBQWEsY0FBYyxvQkFBb0I7QUFDckQsU0FBTyxvQkFBb0I7QUFDN0I7IiwKICAibmFtZXMiOiBbXQp9Cg==
